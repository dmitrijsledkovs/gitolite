<p><head><style>
    body        { margin-left:  40px;   font-size:  0.9em;  font-family: sans-serif; max-width: 800px; }
    h1          { margin-left: -30px;   border-bottom: 5px  solid #ccc; }
    h2, h3      { margin-left: -30px;   border-top:    3px  solid #ddd; }
    h4, h5      { margin-left: -20px; }
    code        { font-size:    1.1em;  background:  #eee; }
    pre         { margin-left:  2em;    background:  #eee; }
    pre code    { font-size:    1.1em;  background:  #eee; }
</style></head></p>

<h1>the 'hub' ADC</h1>

<p>This ADC (admin-defined command) helps collaboration among repos.  The name is
in honor of github, which is the primary host for gitolite itself.</p>

<p>[Note that github is a web-based service, and does a lot more, like comments,
code reviews, etc., none of which are possible here.  We're only talking about
some basic stuff to make the most common operations easier.  In particular,
this system is not a replacement for normal project communications like
email!]</p>

<p>In the following description, we will assume that <strong>Alice</strong> has a repo
<strong>foo</strong>, <strong>Bob</strong> has a fork of foo called <strong>bar</strong>, and he is asking Alice to
pull a branch he made called <strong>b1</strong> from bar to foo.</p>

<p>In plain git (without github etc), the pull request process starts with an
email from Bob to Alice, followed by Alice running a <code>git fetch</code> (possibly
preceded by a <code>git remote add</code>).  Until this happens she can't see much detail
about the commits to be pulled.</p>

<p>What this ADC does is (a) save Alice the trouble of having to type out the
URLs and branch names of the requestor repo's, and (b) allow Alice to examine
the changes with any combination of <code>git log</code> options without having to fetch
the content first.</p>

<p>On the flip side, a thorough examination of the changes required (including
possibly testing) now incurs <em>two</em> fetches -- one from the server side bar.git
to the server side foo.git, then one from there to the foo clone on Alice's
workstation.</p>

<p>[Confused?  In plain git, we don't assume Bob's "server" and Alice's "server"
can directly talk to each other, so anything from Bob to Alice goes from Bob's
server to Alice's workstation and then to Alice's server.  Here we go Bob's
server to Alice's server to Alice's workstation!]</p>

<hr />

<p>The general syntax is</p>

<pre><code>ssh git@server hub &lt;hub-command&gt; &lt;args&gt;
</code></pre>

<p>The following commands do not cause a fetch, and should be quite fast:</p>

<ul>
<li><p>Bob sends a pull request for branch b1 to repo foo.  Notice he does not
mention Alice by name.  This command expects a message to be typed in via
STDIN:</p>

<pre><code>request-pull bar b1 foo
</code></pre></li>
<li><p>Bob lists the status (fetched/rejected/pending) of pull requests he has
made from his repo bar.  (Note we don't say "accepted" but "fetched"; see
later for why):</p>

<pre><code>list-status bar
</code></pre></li>
<li><p>Alice lists requests waiting for her to check and possibly pull into foo.
For each waiting pull request, she will see a serial number, the
originating repo name (bar, in our example), the owner, if applicable
(Bob, here), and the branch/tag-name (b1) being pulled:</p>

<pre><code>list-requests foo
</code></pre></li>
<li><p>Alice views request # 1 waiting to be pulled into foo.  Shows the same
details as above for that request, then displays the message that Bob
typed in when he ran <code>request-pull</code>:</p>

<pre><code>view-request foo 1
</code></pre></li>
<li><p>Alice views the log of the branch she is being asked to pull.  Note that
this does NOT involve a fetch, so it will be pretty fast.  The log starts
from b1, and stops at a SHA that represents any of the branches in foo.
Alice can use any git-log options she wants to; for instance <code>--graph</code>,
<code>--boundary</code>, <code>--decorate</code>, etc., could be quite useful.  However, she
can't use any GUI; it has to be 'git log':</p>

<pre><code>view-log &lt;git log options&gt; foo 1 [SHA]
</code></pre></li>
<li><p>Alice views the diff between arbitrary commits on bar:</p>

<pre><code>view-diff &lt;git diff options&gt; foo 1 SHA1 SHA2
</code></pre></li>
<li><p>Alice doesn't like what she sees and decides to reject it.  This command
expects some text on STDIN as the rejection message:</p>

<pre><code>reject foo 1
</code></pre></li>
</ul>

<p>The following commands will actually fetch from bar into foo, and may take
time if the changes are large.  However all this is on the server so it does
not involve network traffic:</p>

<ul>
<li><p>Alice likes what she sees so far and wants to fetch the branch Bob is
asking her to pull.  Note that we are intentionally not using the word
"accept", because this command does not (and cannot, since it is running
on a bare repo on the server) do a pull.  What it does is it fetches into
a branch whose name will be <code>requests/bar/b1</code>.</p>

<p>Note that when multiple requests from the same repo (bar) for the same
branch (b1) happen, each "fetch" overwrites the branch.  This allows Bob
to continually refine the branch he is requesting for a pull based on
(presumably emailed) comments from Alice.  In a way, this is a "remote
tracking branch", just like <code>refs/remotes/origin/b1</code>.</p>

<pre><code>fetch foo 1
</code></pre></li>
</ul>

<p>At this point, you're done with the <code>hub</code> ADC.  However, all this is on the
bare <code>foo.git</code> on the server, and nothing has hit Alice's workstation yet!
Alice will still have to run a fetch or a pull on her workstation if she wants
to check the code in detail, use a tool like gitk, and expecially to
compile/test it.  <em>Then</em> she decides whether to accept or reject the request,
which will have to be communicated via email, of course; see the second para
of this document ;-)</p>
